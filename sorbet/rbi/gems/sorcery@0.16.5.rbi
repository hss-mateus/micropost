# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sorcery` gem.
# Please instead update this file by running `bin/tapioca gem sorcery`.

class ActiveRecord::Base
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::Serialization
  extend ::Sorcery::Model
end

# a patch to fix a bug in testing that happens when you 'destroy' a session twice.
# After the first destroy, the session is an ordinary hash, and then when destroy
# is called again there's an exception.
#
# source://sorcery//lib/sorcery/test_helpers/internal.rb#20
class Hash
  include ::Enumerable

  # source://sorcery//lib/sorcery/test_helpers/internal.rb#21
  def destroy; end
end

# Each class which calls 'activate_sorcery!' receives an instance of this class.
# Every submodule which gets loaded may add accessors to this class so that all
# options will be configured from a single place.
#
# source://sorcery//lib/sorcery/version.rb#1
module Sorcery; end

# source://sorcery//lib/sorcery.rb#6
module Sorcery::Adapters; end

# source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#3
class Sorcery::Adapters::ActiveRecordAdapter < ::Sorcery::Adapters::BaseAdapter
  # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#22
  def find_authentication_by_oauth_credentials(relation_name, provider, uid); end

  # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#18
  def increment(field); end

  # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#13
  def save(options = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#4
  def update_attributes(attrs); end

  class << self
    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#37
    def define_callback(time, event, method_name, options = T.unsafe(nil)); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#33
    def define_field(name, type, options = T.unsafe(nil)); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#81
    def find_by_activation_token(token); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#55
    def find_by_credentials(credentials); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#100
    def find_by_email(email); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#85
    def find_by_id(id); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#41
    def find_by_oauth_credentials(provider, uid); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#51
    def find_by_remember_me_token(token); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#75
    def find_by_token(token_attr_name, token); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#89
    def find_by_username(username); end

    # source://sorcery//lib/sorcery/adapters/active_record_adapter.rb#104
    def transaction(&blk); end
  end
end

# source://sorcery//lib/sorcery/adapters/base_adapter.rb#3
class Sorcery::Adapters::BaseAdapter
  # @return [BaseAdapter] a new instance of BaseAdapter
  #
  # source://sorcery//lib/sorcery/adapters/base_adapter.rb#4
  def initialize(model); end

  # source://sorcery//lib/sorcery/adapters/base_adapter.rb#21
  def increment(field); end

  # source://sorcery//lib/sorcery/adapters/base_adapter.rb#25
  def update_attribute(name, value); end

  class << self
    # source://sorcery//lib/sorcery/adapters/base_adapter.rb#13
    def delete_all; end

    # source://sorcery//lib/sorcery/adapters/base_adapter.rb#17
    def find(id); end

    # source://sorcery//lib/sorcery/adapters/base_adapter.rb#8
    def from(klass); end
  end
end

# source://sorcery//lib/sorcery/controller.rb#2
module Sorcery::Controller
  include ::Sorcery::Controller::InstanceMethods

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/controller.rb#3
    def included(klass); end
  end
end

# source://sorcery//lib/sorcery/controller/config.rb#3
module Sorcery::Controller::Config
  class << self
    # Returns the value of attribute after_failed_login.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#18
    def after_failed_login; end

    # Sets the attribute after_failed_login
    #
    # @param value the value to set the attribute after_failed_login to.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#18
    def after_failed_login=(_arg0); end

    # Returns the value of attribute after_login.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#17
    def after_login; end

    # Sets the attribute after_login
    #
    # @param value the value to set the attribute after_login to.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#17
    def after_login=(_arg0); end

    # Returns the value of attribute after_logout.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#20
    def after_logout; end

    # Sets the attribute after_logout
    #
    # @param value the value to set the attribute after_logout to.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#20
    def after_logout=(_arg0); end

    # Returns the value of attribute after_remember_me.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#21
    def after_remember_me; end

    # Sets the attribute after_remember_me
    #
    # @param value the value to set the attribute after_remember_me to.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#21
    def after_remember_me=(_arg0); end

    # Returns the value of attribute before_logout.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#19
    def before_logout; end

    # Sets the attribute before_logout
    #
    # @param value the value to set the attribute before_logout to.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#19
    def before_logout=(_arg0); end

    # source://sorcery//lib/sorcery/controller/config.rb#56
    def configure(&blk); end

    # source://sorcery//lib/sorcery/controller/config.rb#60
    def configure!; end

    # set domain option for cookies
    #
    # source://sorcery//lib/sorcery/controller/config.rb#14
    def cookie_domain; end

    # set domain option for cookies
    #
    # source://sorcery//lib/sorcery/controller/config.rb#14
    def cookie_domain=(_arg0); end

    # source://sorcery//lib/sorcery/controller/config.rb#23
    def init!; end

    # Returns the value of attribute login_sources.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#16
    def login_sources; end

    # Sets the attribute login_sources
    #
    # @param value the value to set the attribute login_sources to.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#16
    def login_sources=(_arg0); end

    # what controller action to call for non-authenticated users.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#9
    def not_authenticated_action; end

    # what controller action to call for non-authenticated users.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#9
    def not_authenticated_action=(_arg0); end

    # Resets all configuration options to their default values.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#40
    def reset!; end

    # when a non logged in user tries to enter a page that requires login,
    # save the URL he wanted to reach, and send him there after login.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#12
    def save_return_to_url; end

    # when a non logged in user tries to enter a page that requires login,
    # save the URL he wanted to reach, and send him there after login.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#12
    def save_return_to_url=(_arg0); end

    # Returns the value of attribute submodules.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#5
    def submodules; end

    # Sets the attribute submodules
    #
    # @param value the value to set the attribute submodules to.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#5
    def submodules=(_arg0); end

    # source://sorcery//lib/sorcery/controller/config.rb#46
    def update!; end

    # what class to use as the user class.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#7
    def user_class; end

    # what class to use as the user class.
    #
    # source://sorcery//lib/sorcery/controller/config.rb#7
    def user_class=(_arg0); end

    # source://sorcery//lib/sorcery/controller/config.rb#52
    def user_config(&blk); end
  end
end

# source://sorcery//lib/sorcery/controller.rb#21
module Sorcery::Controller::InstanceMethods
  # login a user instance
  #
  # @param user [<User-Model>] the user instance.
  # @return - do not depend on the return value.
  #
  # source://sorcery//lib/sorcery/controller.rb#116
  def auto_login(user, _should_remember = T.unsafe(nil)); end

  # attempts to auto-login from the sources defined (session, basic_auth, cookie, etc.)
  # returns the logged in user if found, nil if not
  #
  # source://sorcery//lib/sorcery/controller.rb#87
  def current_user; end

  # source://sorcery//lib/sorcery/controller.rb#94
  def current_user=(user); end

  # Overwrite Rails' handle unverified request
  #
  # source://sorcery//lib/sorcery/controller.rb#122
  def handle_unverified_request; end

  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/controller.rb#81
  def logged_in?; end

  # Takes credentials and returns a user on successful authentication.
  # Runs hooks after login or failed login.
  #
  # source://sorcery//lib/sorcery/controller.rb#37
  def login(*credentials); end

  # Resets the session and runs hooks before and after.
  #
  # source://sorcery//lib/sorcery/controller.rb#71
  def logout; end

  # The default action for denying non-authenticated users.
  # You can override this method in your controllers,
  # or provide a different method in the configuration.
  #
  # source://sorcery//lib/sorcery/controller.rb#108
  def not_authenticated; end

  # used when a user tries to access a page while logged out, is asked to login,
  # and we want to return him back to the page he originally wanted.
  #
  # source://sorcery//lib/sorcery/controller.rb#100
  def redirect_back_or_to(url, flash_hash = T.unsafe(nil)); end

  # To be used as before_action.
  # Will trigger auto-login attempts via the call to logged_in?
  # If all attempts to auto-login fail, the failure callback will be called.
  #
  # source://sorcery//lib/sorcery/controller.rb#25
  def require_login; end

  # source://sorcery//lib/sorcery/controller.rb#66
  def reset_sorcery_session; end

  protected

  # source://sorcery//lib/sorcery/controller.rb#149
  def after_failed_login!(credentials); end

  # source://sorcery//lib/sorcery/controller.rb#145
  def after_login!(user, credentials = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/controller.rb#157
  def after_logout!(user); end

  # source://sorcery//lib/sorcery/controller.rb#161
  def after_remember_me!(user); end

  # source://sorcery//lib/sorcery/controller.rb#153
  def before_logout!; end

  # Tries all available sources (methods) until one doesn't return false.
  #
  # source://sorcery//lib/sorcery/controller.rb#131
  def login_from_other_sources; end

  # source://sorcery//lib/sorcery/controller.rb#139
  def login_from_session; end

  # source://sorcery//lib/sorcery/controller.rb#165
  def user_class; end
end

# source://sorcery//lib/sorcery.rb#29
module Sorcery::Controller::Submodules; end

# This submodule keeps track of events such as login, logout,
# and last activity time, per user.
# It helps in estimating which users are active now in the site.
# This cannot be determined absolutely because a user might be
# reading a page without clicking anything for a while.
# This is the controller part of the submodule, which adds hooks
# to register user events,
# and methods to collect active users data for use in the app.
# see Socery::Model::Submodules::ActivityLogging for configuration
# options.
#
# source://sorcery//lib/sorcery/controller/submodules/activity_logging.rb#14
module Sorcery::Controller::Submodules::ActivityLogging
  include ::Sorcery::Controller::Submodules::ActivityLogging::InstanceMethods

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/controller/submodules/activity_logging.rb#15
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/controller/submodules/activity_logging.rb#41
module Sorcery::Controller::Submodules::ActivityLogging::InstanceMethods
  protected

  # Updates last activity time on every request.
  # The only exception is logout - we do not update activity on logout
  #
  # source://sorcery//lib/sorcery/controller/submodules/activity_logging.rb#62
  def register_last_activity_time_to_db; end

  # Updates IP address on every login.
  # This runs as a hook just after a successful login.
  #
  # source://sorcery//lib/sorcery/controller/submodules/activity_logging.rb#71
  def register_last_ip_address(_user, _credentials); end

  # registers last login time on every login.
  # This runs as a hook just after a successful login.
  #
  # source://sorcery//lib/sorcery/controller/submodules/activity_logging.rb#46
  def register_login_time_to_db(user, _credentials); end

  # registers last logout time on every logout.
  # This runs as a hook just before a logout.
  #
  # source://sorcery//lib/sorcery/controller/submodules/activity_logging.rb#54
  def register_logout_time_to_db; end
end

# This module helps protect user accounts by locking them down after too
# many failed attemps to login were detected.
# This is the controller part of the submodule which takes care of
# updating the failed logins and resetting them.
# See Sorcery::Model::Submodules::BruteForceProtection for configuration
# options.
#
# source://sorcery//lib/sorcery/controller/submodules/brute_force_protection.rb#10
module Sorcery::Controller::Submodules::BruteForceProtection
  include ::Sorcery::Controller::Submodules::BruteForceProtection::InstanceMethods

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/controller/submodules/brute_force_protection.rb#11
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/controller/submodules/brute_force_protection.rb#18
module Sorcery::Controller::Submodules::BruteForceProtection::InstanceMethods
  protected

  # Resets the failed logins counter.
  # Runs as a hook after a successful login.
  #
  # source://sorcery//lib/sorcery/controller/submodules/brute_force_protection.rb#30
  def reset_failed_logins_count!(user, _credentials); end

  # Increments the failed logins counter on every failed login.
  # Runs as a hook after a failed login.
  #
  # source://sorcery//lib/sorcery/controller/submodules/brute_force_protection.rb#23
  def update_failed_logins_count!(credentials); end
end

# This submodule helps you login users from external auth providers such as Twitter.
# This is the controller part which handles the http requests and tokens passed between the app and the @provider.
#
# source://sorcery//lib/sorcery/controller/submodules/external.rb#6
module Sorcery::Controller::Submodules::External
  include ::Sorcery::Controller::Submodules::External::InstanceMethods

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/controller/submodules/external.rb#7
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/controller/submodules/external.rb#58
module Sorcery::Controller::Submodules::External::InstanceMethods
  protected

  # for backwards compatibility
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#100
  def access_token(*_args); end

  # If user is logged, he can add all available providers into his account
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#145
  def add_provider_to_user(provider_name); end

  # follows the same patterns as create_from, but builds the user instead of creating
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#198
  def build_from(provider_name, &block); end

  # Initialize new user from provider informations.
  # If a provider doesn't give required informations or username/email is already taken,
  # we store provider/user infos into a session and can be rendered into registration form
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#155
  def create_and_validate_from(provider_name); end

  # this method automatically creates a new user from the data in the external user hash.
  # The mappings from user hash fields to user db fields are set at controller config.
  # If the hash field you would like to map is nested, use slashes. For example, Given a hash like:
  #
  #   "user" => {"name"=>"moishe"}
  #
  # You will set the mapping:
  #
  #   {:username => "user/name"}
  #
  # And this will cause 'moishe' to be set as the value of :username field.
  # Note: Be careful. This method skips validations model.
  # Instead you can pass a block, if the block returns false the user will not be created
  #
  #   create_from(provider) {|user| user.some_check }
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#189
  def create_from(provider_name, &block); end

  # sends user to authenticate at the provider's website.
  # after authentication the user is redirected to the callback defined in the provider config
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#120
  def login_at(provider_name, args = T.unsafe(nil)); end

  # tries to login the user from provider's callback
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#125
  def login_from(provider_name, should_remember = T.unsafe(nil)); end

  # get the user hash from a provider using information from the params and session.
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#81
  def sorcery_fetch_user_hash(provider_name); end

  # this method should be somewhere else.  It only does something once per application per provider.
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#105
  def sorcery_fixup_callback_url(provider); end

  # save the singleton ProviderClient instance into @provider
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#62
  def sorcery_get_provider(provider_name); end

  # get the login URL from the provider, if applicable.  Returns nil if the provider
  # does not provide a login URL.  (as of v0.8.1 all providers provide a login URL)
  #
  # source://sorcery//lib/sorcery/controller/submodules/external.rb#70
  def sorcery_login_url(provider_name, args = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/controller/submodules/external.rb#206
  def user_attrs(user_info_mapping, user_hash); end
end

# This submodule integrates HTTP Basic authentication into sorcery.
# You are provided with a before action, require_login_from_http_basic,
# which requests the browser for authentication.
# Then the rest of the submodule takes care of logging the user in
# into the session, so that the next requests will keep him logged in.
#
# source://sorcery//lib/sorcery/controller/submodules/http_basic_auth.rb#9
module Sorcery::Controller::Submodules::HttpBasicAuth
  include ::Sorcery::Controller::Submodules::HttpBasicAuth::InstanceMethods

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/controller/submodules/http_basic_auth.rb#10
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/controller/submodules/http_basic_auth.rb#26
module Sorcery::Controller::Submodules::HttpBasicAuth::InstanceMethods
  protected

  # given to main controller module as a login source callback
  #
  # source://sorcery//lib/sorcery/controller/submodules/http_basic_auth.rb#46
  def login_from_basic_auth; end

  # Sets the realm name by searching the controller name in the hash given at configuration time.
  #
  # source://sorcery//lib/sorcery/controller/submodules/http_basic_auth.rb#55
  def realm_name_by_controller; end

  # to be used as a before_action.
  # The method sets a session when requesting the user's credentials.
  # This is a trick to overcome the way HTTP authentication works (explained below):
  #
  # Once the user fills the credentials once, the browser will always send it to the
  # server when visiting the website, until the browser is closed.
  # This causes wierd behaviour if the user logs out. The session is reset, yet the
  # user is re-logged in by the before_action calling 'login_from_basic_auth'.
  # To overcome this, we set a session when requesting the password, which logout will
  # reset, and that's how we know if we need to request for HTTP auth again.
  #
  # source://sorcery//lib/sorcery/controller/submodules/http_basic_auth.rb#39
  def require_login_from_http_basic; end
end

# The Remember Me submodule takes care of setting the user's cookie so that he will
# be automatically logged in to the site on every visit,
# until the cookie expires.
# See Sorcery::Model::Submodules::RememberMe for configuration options.
#
# source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#8
module Sorcery::Controller::Submodules::RememberMe
  include ::Sorcery::Controller::Submodules::RememberMe::InstanceMethods

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#9
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#25
module Sorcery::Controller::Submodules::RememberMe::InstanceMethods
  # Override.
  # logins a user instance, and optionally remembers him.
  #
  # source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#46
  def auto_login(user, should_remember = T.unsafe(nil)); end

  # Clears the cookie, and clears the token value.
  #
  # source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#39
  def force_forget_me!; end

  # Clears the cookie, and depending on the value of remember_me_token_persist_globally, may clear the token value.
  #
  # source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#33
  def forget_me!; end

  # This method sets the cookie and calls the user to save the token and the expiration to db.
  #
  # source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#27
  def remember_me!; end

  protected

  # Checks the cookie for a remember me token, tried to find a user with that token
  # and logs the user in if found.
  # Runs as a login source. See 'current_user' method for how it is used.
  #
  # source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#57
  def login_from_cookie; end

  # source://sorcery//lib/sorcery/controller/submodules/remember_me.rb#69
  def set_remember_me_cookie!(user); end
end

# This submodule helps you set a timeout to all user sessions.
# The timeout can be configured and also you can choose to reset it on every user action.
#
# source://sorcery//lib/sorcery/controller/submodules/session_timeout.rb#6
module Sorcery::Controller::Submodules::SessionTimeout
  include ::Sorcery::Controller::Submodules::SessionTimeout::InstanceMethods

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/controller/submodules/session_timeout.rb#7
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/controller/submodules/session_timeout.rb#33
module Sorcery::Controller::Submodules::SessionTimeout::InstanceMethods
  # source://sorcery//lib/sorcery/controller/submodules/session_timeout.rb#34
  def invalidate_active_sessions!; end

  protected

  # Registers last login to be used as the timeout starting point.
  # Runs as a hook after a successful login.
  #
  # source://sorcery//lib/sorcery/controller/submodules/session_timeout.rb#46
  def register_login_time(_user, _credentials = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/controller/submodules/session_timeout.rb#62
  def sorcery_session_expired?(time); end

  # Use login time if present, otherwise use last action time.
  #
  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/controller/submodules/session_timeout.rb#67
  def sorcery_session_invalidated?; end

  # Checks if session timeout was reached and expires the current session if so.
  # To be used as a before_action, before require_login
  #
  # source://sorcery//lib/sorcery/controller/submodules/session_timeout.rb#52
  def validate_session; end
end

# The activate_sorcery method has a custom_crypto_provider configuration option.
# This allows you to use any type of encryption you like.
# Just create a class with a class level encrypt and matches? method. See example below.
#
# === Example
#
#   class MyAwesomeEncryptionMethod
#     def self.encrypt(*tokens)
#       # the tokens passed will be an array of objects, what type of object is irrelevant,
#       # just do what you need to do with them and return a single encrypted string.
#       # for example, you will most likely join all of the objects into a single string and then encrypt that string
#     end
#
#     def self.matches?(crypted, *tokens)
#       # return true if the crypted string matches the tokens.
#       # depending on your algorithm you might decrypt the string then compare it to the token, or you might
#       # encrypt the tokens and make sure it matches the crypted string, its up to you
#     end
#   end
#
# source://sorcery//lib/sorcery.rb#44
module Sorcery::CryptoProviders; end

# This encryption method is reversible if you have the supplied key.
# So in order to use this encryption method you must supply it with a key first.
# In an initializer, or before your application initializes, you should do the following:
#
#   Sorcery::Model::ConfigAES256.key = "my 32 bytes long key"
#
# My final comment is that this is a strong encryption method,
# but its main weakness is that its reversible. If you do not need to reverse the hash
# then you should consider Sha512 or BCrypt instead.
#
# Keep your key in a safe place, some even say the key should be stored on a separate server.
# This won't hurt performance because the only time it will try and access the key on the
# separate server is during initialization, which only
# happens once. The reasoning behind this is if someone does compromise your server they
# won't have the key also. Basically, you don't want to store the key with the lock.
#
# source://sorcery//lib/sorcery/crypto_providers/aes256.rb#20
class Sorcery::CryptoProviders::AES256
  class << self
    # source://sorcery//lib/sorcery/crypto_providers/aes256.rb#36
    def decrypt(crypted); end

    # source://sorcery//lib/sorcery/crypto_providers/aes256.rb#24
    def encrypt(*tokens); end

    # Sets the attribute key
    #
    # @param value the value to set the attribute key to.
    #
    # source://sorcery//lib/sorcery/crypto_providers/aes256.rb#22
    def key=(_arg0); end

    # @return [Boolean]
    #
    # source://sorcery//lib/sorcery/crypto_providers/aes256.rb#30
    def matches?(crypted, *tokens); end

    private

    # @raise [ArgumentError]
    #
    # source://sorcery//lib/sorcery/crypto_providers/aes256.rb#44
    def aes; end
  end
end

# For most apps Sha512 is plenty secure, but if you are building an app that stores nuclear
# launch codes you might want to consier BCrypt. This is an extremely
# secure hashing algorithm, mainly because it is slow.
# A brute force attack on a BCrypt encrypted password would take much longer than a brute force attack on a
# password encrypted with a Sha algorithm. Keep in mind you are sacrificing performance by using this,
# generating a password takes exponentially longer than any
# of the Sha algorithms. I did some benchmarking to save you some time with your decision:
#
#   require "bcrypt"
#   require "digest"
#   require "benchmark"
#
#   Benchmark.bm(18) do |x|
#     x.report("BCrypt (cost = 10:") { 100.times { BCrypt::Password.create("mypass", :cost => 10) } }
#     x.report("BCrypt (cost = 2:") { 100.times { BCrypt::Password.create("mypass", :cost => 2) } }
#     x.report("Sha512:") { 100.times { Digest::SHA512.hexdigest("mypass") } }
#     x.report("Sha1:") { 100.times { Digest::SHA1.hexdigest("mypass") } }
#   end
#
#                           user     system      total        real
#   BCrypt (cost = 10): 10.780000   0.060000  10.840000 ( 11.100289)
#   BCrypt (cost = 2):  0.180000   0.000000   0.180000 (  0.181914)
#   Sha512:             0.000000   0.000000   0.000000 (  0.000829)
#   Sha1:               0.000000   0.000000   0.000000 (  0.000395)
#
# You can play around with the cost to get that perfect balance between performance and security.
#
# Decided BCrypt is for you? Just insall the bcrypt gem:
#
#   gem install bcrypt-ruby
#
# Update your initializer to use it:
#
#   config.encryption_algorithm = :bcrypt
#
# You are good to go!
#
# source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#41
class Sorcery::CryptoProviders::BCrypt
  class << self
    # This is the :cost option for the BCrpyt library.
    # The higher the cost the more secure it is and the longer is take the generate a hash. By default this is 10.
    # Set this to whatever you want, play around with it to get that perfect balance between
    # security and performance.
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#51
    def cost; end

    # Sets the attribute cost
    #
    # @param value the value to set the attribute cost to.
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#54
    def cost=(_arg0); end

    # This method is used as a flag to tell Sorcery to "resave" the password
    # upon a successful login, using the new cost
    #
    # @return [Boolean]
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#73
    def cost_matches?(hash); end

    # Creates a BCrypt hash for the password passed.
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#59
    def encrypt(*tokens); end

    # Does the hash match the tokens? Uses the same tokens that were used to encrypt.
    #
    # @return [Boolean]
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#64
    def matches?(hash, *tokens); end

    # Setting the option :pepper allows users to append an app-specific secret token.
    # Basically it's equivalent to :salt_join_token option, but have a different name to ensure
    # backward compatibility in generating/matching passwords.
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#46
    def pepper; end

    # Setting the option :pepper allows users to append an app-specific secret token.
    # Basically it's equivalent to :salt_join_token option, but have a different name to ensure
    # backward compatibility in generating/matching passwords.
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#46
    def pepper=(_arg0); end

    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#82
    def reset!; end

    # This is the :cost option for the BCrpyt library.
    # The higher the cost the more secure it is and the longer is take the generate a hash. By default this is 10.
    # Set this to whatever you want, play around with it to get that perfect balance between
    # security and performance.
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#51
    def stretches; end

    # Sets the attribute cost
    #
    # @param value the value to set the attribute cost to.
    #
    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#54
    def stretches=(_arg0); end

    private

    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#89
    def join_tokens(tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/bcrypt.rb#93
    def new_from_hash(hash); end
  end
end

# source://sorcery//lib/sorcery/crypto_providers/common.rb#3
module Sorcery::CryptoProviders::Common
  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/crypto_providers/common.rb#4
    def included(base); end
  end
end

# This class was made for the users transitioning from md5 based systems.
# I highly discourage using this crypto provider as it superbly inferior
# to your other options.
#
# Please use any other provider offered by Sorcery.
#
# source://sorcery//lib/sorcery/crypto_providers/md5.rb#10
class Sorcery::CryptoProviders::MD5
  include ::Sorcery::CryptoProviders::Common

  class << self
    # source://sorcery//lib/sorcery/crypto_providers/common.rb#15
    def encrypt(*tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#7
    def join_token; end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#7
    def join_token=(_arg0); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#22
    def matches?(crypted, *tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#26
    def reset!; end

    # source://sorcery//lib/sorcery/crypto_providers/md5.rb#13
    def secure_digest(digest); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#10
    def stretches; end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#13
    def stretches=(_arg0); end
  end
end

# This class was made for the users transitioning from restful_authentication. I highly discourage using this
# crypto provider as it inferior to your other options. Please use any other provider offered by Sorcery.
#
# source://sorcery//lib/sorcery/crypto_providers/sha1.rb#7
class Sorcery::CryptoProviders::SHA1
  include ::Sorcery::CryptoProviders::Common

  class << self
    # Turns your raw password into a Sha1 hash.
    #
    # source://sorcery//lib/sorcery/crypto_providers/sha1.rb#15
    def encrypt(*tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/sha1.rb#10
    def join_token; end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#7
    def join_token=(_arg0); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#22
    def matches?(crypted, *tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#26
    def reset!; end

    # source://sorcery//lib/sorcery/crypto_providers/sha1.rb#22
    def secure_digest(digest); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#10
    def stretches; end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#13
    def stretches=(_arg0); end
  end
end

# = Sha256
#
# Uses the Sha256 hash algorithm to encrypt passwords.
#
# source://sorcery//lib/sorcery/crypto_providers/sha256.rb#27
class Sorcery::CryptoProviders::SHA256
  include ::Sorcery::CryptoProviders::Common

  class << self
    # source://sorcery//lib/sorcery/crypto_providers/common.rb#15
    def encrypt(*tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#7
    def join_token; end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#7
    def join_token=(_arg0); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#22
    def matches?(crypted, *tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#26
    def reset!; end

    # source://sorcery//lib/sorcery/crypto_providers/sha256.rb#30
    def secure_digest(digest); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#10
    def stretches; end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#13
    def stretches=(_arg0); end
  end
end

# = Sha512
#
# Uses the Sha512 hash algorithm to encrypt passwords.
#
# source://sorcery//lib/sorcery/crypto_providers/sha512.rb#27
class Sorcery::CryptoProviders::SHA512
  include ::Sorcery::CryptoProviders::Common

  class << self
    # source://sorcery//lib/sorcery/crypto_providers/common.rb#15
    def encrypt(*tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#7
    def join_token; end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#7
    def join_token=(_arg0); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#22
    def matches?(crypted, *tokens); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#26
    def reset!; end

    # source://sorcery//lib/sorcery/crypto_providers/sha512.rb#30
    def secure_digest(digest); end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#10
    def stretches; end

    # source://sorcery//lib/sorcery/crypto_providers/common.rb#13
    def stretches=(_arg0); end
  end
end

# The Sorcery engine takes care of extending ActiveRecord (if used) and ActionController,
# With the plugin logic.
#
# source://sorcery//lib/sorcery/engine.rb#7
class Sorcery::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.0.5/lib/active_support/callbacks.rb#68
    def __callbacks; end
  end
end

# This module handles all plugin operations which are related to the Model layer in the MVC pattern.
# It should be included into the ORM base class.
# In the case of Rails this is usually ActiveRecord (actually, in that case, the plugin does this automatically).
#
# When included it defines a single method: 'authenticates_with_sorcery!'
# which when called adds the other capabilities to the class.
# This method is also the place to configure the plugin in the Model layer.
#
# source://sorcery//lib/sorcery/model.rb#9
module Sorcery::Model
  # source://sorcery//lib/sorcery/model.rb#10
  def authenticates_with_sorcery!; end

  private

  # source://sorcery//lib/sorcery/model.rb#31
  def define_base_fields; end

  # includes required submodules into the model class,
  # which usually is called User.
  #
  # source://sorcery//lib/sorcery/model.rb#46
  def include_required_submodules!; end

  # add virtual password accessor and ORM callbacks.
  #
  # source://sorcery//lib/sorcery/model.rb#64
  def init_orm_hooks!; end
end

# source://sorcery//lib/sorcery/model.rb#76
module Sorcery::Model::ClassMethods
  # The default authentication method.
  # Takes a username and password,
  # Finds the user by the username and compares the user's password to the one supplied to the method.
  # returns the user if success, nil otherwise.
  #
  # @raise [ArgumentError]
  #
  # source://sorcery//lib/sorcery/model.rb#86
  def authenticate(*credentials, &block); end

  # encrypt tokens using current encryption_provider.
  #
  # source://sorcery//lib/sorcery/model.rb#125
  def encrypt(*tokens); end

  # FIXME: This method of passing config to the hashing provider is
  #        questionable, and has been refactored in Sorcery v1.
  #
  # source://sorcery//lib/sorcery/model.rb#136
  def set_encryption_attributes; end

  # Returns the class instance variable for configuration, when called by the class itself.
  #
  # source://sorcery//lib/sorcery/model.rb#78
  def sorcery_config; end

  protected

  # source://sorcery//lib/sorcery/model.rb#150
  def add_config_inheritance; end

  # @yield [options[:user], options[:failure]]
  #
  # source://sorcery//lib/sorcery/model.rb#144
  def authentication_response(options = T.unsafe(nil)); end
end

# source://sorcery//lib/sorcery/model/config.rb#6
class Sorcery::Model::Config
  # @return [Config] a new instance of Config
  #
  # source://sorcery//lib/sorcery/model/config.rb#52
  def initialize; end

  # an array of method names to call after configuration by user. used internally.
  #
  # source://sorcery//lib/sorcery/model/config.rb#39
  def after_config; end

  # an array of method names to call after configuration by user. used internally.
  #
  # source://sorcery//lib/sorcery/model/config.rb#39
  def after_config=(_arg0); end

  # an array of method names to call before authentication completes. used internally.
  #
  # source://sorcery//lib/sorcery/model/config.rb#32
  def before_authenticate; end

  # an array of method names to call before authentication completes. used internally.
  #
  # source://sorcery//lib/sorcery/model/config.rb#32
  def before_authenticate=(_arg0); end

  # change default crypted_password attribute.
  #
  # source://sorcery//lib/sorcery/model/config.rb#14
  def crypted_password_attribute_name; end

  # change default crypted_password attribute.
  #
  # source://sorcery//lib/sorcery/model/config.rb#14
  def crypted_password_attribute_name=(_arg0); end

  # use an external encryption class.
  #
  # source://sorcery//lib/sorcery/model/config.rb#48
  def custom_encryption_provider; end

  # source://sorcery//lib/sorcery/model/config.rb#88
  def custom_encryption_provider=(provider); end

  # downcase the username before trying to authenticate, default is false
  #
  # source://sorcery//lib/sorcery/model/config.rb#12
  def downcase_username_before_authenticating; end

  # downcase the username before trying to authenticate, default is false
  #
  # source://sorcery//lib/sorcery/model/config.rb#12
  def downcase_username_before_authenticating=(_arg0); end

  # change default email attribute.
  #
  # source://sorcery//lib/sorcery/model/config.rb#10
  def email_attribute_name; end

  # change default email attribute.
  #
  # source://sorcery//lib/sorcery/model/config.rb#10
  def email_attribute_name=(_arg0); end

  # method to send email related
  # options: `:deliver_later`, `:deliver_now`, `:deliver`
  # Default: :deliver (Rails version < 4.2) or :deliver_now (Rails version 4.2+)
  # method to send email related
  #
  # source://sorcery//lib/sorcery/model/config.rb#37
  def email_delivery_method; end

  # method to send email related
  # options: `:deliver_later`, `:deliver_now`, `:deliver`
  # Default: :deliver (Rails version < 4.2) or :deliver_now (Rails version 4.2+)
  # method to send email related
  #
  # source://sorcery//lib/sorcery/model/config.rb#37
  def email_delivery_method=(_arg0); end

  # encryption algorithm name. See 'encryption_algorithm=' below for available options.
  #
  # source://sorcery//lib/sorcery/model/config.rb#50
  def encryption_algorithm; end

  # source://sorcery//lib/sorcery/model/config.rb#92
  def encryption_algorithm=(algo); end

  # encryption key used to encrypt reversible encryptions such as AES256.
  #
  # source://sorcery//lib/sorcery/model/config.rb#26
  def encryption_key; end

  # encryption key used to encrypt reversible encryptions such as AES256.
  #
  # source://sorcery//lib/sorcery/model/config.rb#26
  def encryption_key=(_arg0); end

  # change default encryption_provider.
  #
  # source://sorcery//lib/sorcery/model/config.rb#46
  def encryption_provider; end

  # change *virtual* password attribute, the one which is used until an encrypted one is generated.
  #
  # source://sorcery//lib/sorcery/model/config.rb#8
  def password_attribute_name; end

  # change *virtual* password attribute, the one which is used until an encrypted one is generated.
  #
  # source://sorcery//lib/sorcery/model/config.rb#8
  def password_attribute_name=(_arg0); end

  # application-specific secret token that is joined with the password and its salt.
  # Currently available with BCrypt (default crypt provider) only.
  #
  # source://sorcery//lib/sorcery/model/config.rb#17
  def pepper; end

  # application-specific secret token that is joined with the password and its salt.
  # Currently available with BCrypt (default crypt provider) only.
  #
  # source://sorcery//lib/sorcery/model/config.rb#17
  def pepper=(_arg0); end

  # Resets all configuration options to their default values.
  #
  # source://sorcery//lib/sorcery/model/config.rb#78
  def reset!; end

  # change default salt attribute.
  #
  # source://sorcery//lib/sorcery/model/config.rb#22
  def salt_attribute_name; end

  # change default salt attribute.
  #
  # source://sorcery//lib/sorcery/model/config.rb#22
  def salt_attribute_name=(_arg0); end

  # what pattern to use to join the password with the salt
  # APPLICABLE TO MD5, SHA1, SHA256, SHA512. Other crypt providers (incl. BCrypt) ignore this parameter.
  #
  # source://sorcery//lib/sorcery/model/config.rb#20
  def salt_join_token; end

  # what pattern to use to join the password with the salt
  # APPLICABLE TO MD5, SHA1, SHA256, SHA512. Other crypt providers (incl. BCrypt) ignore this parameter.
  #
  # source://sorcery//lib/sorcery/model/config.rb#20
  def salt_join_token=(_arg0); end

  # how many times to apply encryption to the password.
  #
  # source://sorcery//lib/sorcery/model/config.rb#24
  def stretches; end

  # how many times to apply encryption to the password.
  #
  # source://sorcery//lib/sorcery/model/config.rb#24
  def stretches=(_arg0); end

  # make this configuration inheritable for subclasses. Useful for ActiveRecord's STI.
  #
  # source://sorcery//lib/sorcery/model/config.rb#28
  def subclasses_inherit_config; end

  # make this configuration inheritable for subclasses. Useful for ActiveRecord's STI.
  #
  # source://sorcery//lib/sorcery/model/config.rb#28
  def subclasses_inherit_config=(_arg0); end

  # configured in config/application.rb
  #
  # source://sorcery//lib/sorcery/model/config.rb#30
  def submodules; end

  # configured in config/application.rb
  #
  # source://sorcery//lib/sorcery/model/config.rb#30
  def submodules=(_arg0); end

  # Set token randomness
  #
  # source://sorcery//lib/sorcery/model/config.rb#41
  def token_randomness; end

  # Set token randomness
  #
  # source://sorcery//lib/sorcery/model/config.rb#41
  def token_randomness=(_arg0); end

  # change default username attribute, for example, to use :email as the login. See 'username_attribute_names=' below.
  #
  # source://sorcery//lib/sorcery/model/config.rb#44
  def username_attribute_names; end

  # source://sorcery//lib/sorcery/model/config.rb#84
  def username_attribute_names=(fields); end

  private

  # source://sorcery//lib/sorcery/model/config.rb#109
  def default_email_delivery_method; end

  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/config.rb#114
  def rails_version_bigger_than_or_equal?(version); end
end

# source://sorcery//lib/sorcery/model.rb#165
module Sorcery::Model::InstanceMethods
  # identifies whether this user is regular, i.e. we hold his credentials in our db,
  # or that he is external, and his credentials are saved elsewhere (twitter/facebook etc.).
  #
  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model.rb#173
  def external?; end

  # Returns the class instance variable for configuration, when called by an instance.
  #
  # source://sorcery//lib/sorcery/model.rb#167
  def sorcery_config; end

  # Calls the configured encryption provider to compare the supplied password with the encrypted one.
  #
  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model.rb#178
  def valid_password?(pass); end

  protected

  # source://sorcery//lib/sorcery/model.rb#200
  def clear_virtual_password; end

  # creates new salt and saves it.
  # encrypts password with salt and saves it.
  #
  # source://sorcery//lib/sorcery/model.rb#194
  def encrypt_password; end

  # calls the requested email method on the configured mailer
  # supports both the ActionMailer 3 way of calling, and the plain old Ruby object way.
  #
  # source://sorcery//lib/sorcery/model.rb#211
  def generic_send_email(method, mailer); end
end

# source://sorcery//lib/sorcery.rb#14
module Sorcery::Model::Submodules; end

# This submodule keeps track of events such as login, logout, and last activity time, per user.
# It helps in estimating which users are active now in the site.
# This cannot be determined absolutely because a user might be reading a page without clicking anything
# for a while.
# This is the model part of the submodule, which provides configuration options.
#
# source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#9
module Sorcery::Model::Submodules::ActivityLogging
  include ::Sorcery::Model::Submodules::ActivityLogging::InstanceMethods

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#10
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#76
module Sorcery::Model::Submodules::ActivityLogging::ClassMethods
  protected

  # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#79
  def define_activity_logging_fields; end
end

# source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#39
module Sorcery::Model::Submodules::ActivityLogging::InstanceMethods
  # shows if user is logged in, but it not show if user is online - see online?
  #
  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#64
  def logged_in?; end

  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#71
  def logged_out?; end

  # online method shows if user is active (logout action makes user inactive too)
  #
  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#57
  def online?; end

  # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#48
  def set_last_activity_at(time); end

  # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#52
  def set_last_ip_address(ip_address); end

  # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#40
  def set_last_login_at(time); end

  # source://sorcery//lib/sorcery/model/submodules/activity_logging.rb#44
  def set_last_logout_at(time); end
end

# This module helps protect user accounts by locking them down after too many failed attemps
# to login were detected.
# This is the model part of the submodule which provides configuration options and methods
# for locking and unlocking the user.
#
# source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#8
module Sorcery::Model::Submodules::BruteForceProtection
  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#9
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#42
module Sorcery::Model::Submodules::BruteForceProtection::ClassMethods
  # This doesn't check to see if the account is still locked
  #
  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#44
  def load_from_unlock_token(token, &block); end

  protected

  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#56
  def define_brute_force_protection_fields; end
end

# source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#63
module Sorcery::Model::Submodules::BruteForceProtection::InstanceMethods
  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#88
  def login_locked?; end

  # /!\
  # Moved out of protected for use like activate! in controller
  # /!\
  #
  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#80
  def login_unlock!; end

  # Called by the controller to increment the failed logins counter.
  # Calls 'login_lock!' if login retries limit was reached.
  #
  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#66
  def register_failed_login!; end

  protected

  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#94
  def login_lock!; end

  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#105
  def login_unlocked?; end

  # Prevents a locked user from logging in, and unlocks users that expired their lock time.
  # Runs as a hook before authenticate.
  #
  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#118
  def prevent_locked_user_login; end

  # source://sorcery//lib/sorcery/model/submodules/brute_force_protection.rb#110
  def send_unlock_token_email!; end
end

# This submodule helps you login users from external providers such as Twitter.
# This is the model part which handles finding the user using access tokens.
# For the controller options see Sorcery::Controller::External.
#
# Socery assumes (read: requires) you will create external users in the same table where
# you keep your regular users,
# but that you will have a separate table for keeping their external authentication data,
# and that that separate table has a few rows for each user, facebook and twitter
# for example (a one-to-many relationship).
#
# External users will have a null crypted_password field, since we do not hold their password.
# They will not be sent activation emails on creation.
#
# source://sorcery//lib/sorcery/model/submodules/external.rb#16
module Sorcery::Model::Submodules::External
  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/model/submodules/external.rb#17
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/model/submodules/external.rb#38
module Sorcery::Model::Submodules::External::ClassMethods
  # NOTE: Should this build the authentication as well and return [user, auth]?
  # Currently, users call this function for the user and call add_provider_to_user after saving
  #
  # source://sorcery//lib/sorcery/model/submodules/external.rb#80
  def build_from_provider(attrs); end

  # source://sorcery//lib/sorcery/model/submodules/external.rb#47
  def create_and_validate_from_provider(provider, uid, attrs); end

  # source://sorcery//lib/sorcery/model/submodules/external.rb#57
  def create_from_provider(provider, uid, attrs); end

  # takes a provider and uid and finds a user by them.
  #
  # source://sorcery//lib/sorcery/model/submodules/external.rb#40
  def load_from_provider(provider, uid); end
end

# source://sorcery//lib/sorcery/model/submodules/external.rb#94
module Sorcery::Model::Submodules::External::InstanceMethods
  # source://sorcery//lib/sorcery/model/submodules/external.rb#95
  def add_provider_to_user(provider, uid); end
end

# This submodule adds the ability to login via email without password.
# When the user requests an email is sent to him with a url.
# The url includes a token, which is also saved with the user's record in the db.
# The token has configurable expiration.
# When the user clicks the url in the email, providing the token has not yet expired,
# he will be able to login.
#
# When using this submodule, supplying a mailer is mandatory.
#
# source://sorcery//lib/sorcery/model/submodules/magic_login.rb#12
module Sorcery::Model::Submodules::MagicLogin
  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/model/submodules/magic_login.rb#13
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/model/submodules/magic_login.rb#52
module Sorcery::Model::Submodules::MagicLogin::ClassMethods
  # Find user by token, also checks for expiration.
  # Returns the user if token found and is valid.
  #
  # source://sorcery//lib/sorcery/model/submodules/magic_login.rb#55
  def load_from_magic_login_token(token, &block); end

  protected

  # source://sorcery//lib/sorcery/model/submodules/magic_login.rb#73
  def define_magic_login_fields; end

  # This submodule requires the developer to define his own mailer class to be used by it
  # when magic_login_mailer_disabled is false
  #
  # @raise [ArgumentError]
  #
  # source://sorcery//lib/sorcery/model/submodules/magic_login.rb#68
  def validate_mailer_defined; end
end

# source://sorcery//lib/sorcery/model/submodules/magic_login.rb#80
module Sorcery::Model::Submodules::MagicLogin::InstanceMethods
  # Clears the token.
  #
  # source://sorcery//lib/sorcery/model/submodules/magic_login.rb#113
  def clear_magic_login_token!; end

  # generates a magic login code with expiration and sends an email to the user.
  #
  # source://sorcery//lib/sorcery/model/submodules/magic_login.rb#94
  def deliver_magic_login_instructions!; end

  # generates a reset code with expiration
  #
  # source://sorcery//lib/sorcery/model/submodules/magic_login.rb#82
  def generate_magic_login_token!; end

  protected

  # source://sorcery//lib/sorcery/model/submodules/magic_login.rb#123
  def send_magic_login_email!; end
end

# The Remember Me submodule takes care of setting the user's cookie so that he will
# be automatically logged in to the site on every visit,
# until the cookie expires.
#
# source://sorcery//lib/sorcery/model/submodules/remember_me.rb#7
module Sorcery::Model::Submodules::RememberMe
  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/model/submodules/remember_me.rb#8
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/model/submodules/remember_me.rb#31
module Sorcery::Model::Submodules::RememberMe::ClassMethods
  protected

  # source://sorcery//lib/sorcery/model/submodules/remember_me.rb#34
  def define_remember_me_fields; end
end

# source://sorcery//lib/sorcery/model/submodules/remember_me.rb#40
module Sorcery::Model::Submodules::RememberMe::InstanceMethods
  # You shouldn't really use this one yourself - it's called by the controller's 'force_forget_me!' method.
  #
  # source://sorcery//lib/sorcery/model/submodules/remember_me.rb#65
  def force_forget_me!; end

  # You shouldn't really use this one yourself - it's called by the controller's 'forget_me!' method.
  # We only clear the token value if remember_me_token_persist_globally = true.
  #
  # source://sorcery//lib/sorcery/model/submodules/remember_me.rb#60
  def forget_me!; end

  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/submodules/remember_me.rb#54
  def has_remember_me_token?; end

  # You shouldn't really use this one yourself - it's called by the controller's 'remember_me!' method.
  #
  # source://sorcery//lib/sorcery/model/submodules/remember_me.rb#42
  def remember_me!; end
end

# This submodule adds the ability to reset password via email confirmation.
# When the user requests an email is sent to him with a url.
# The url includes a token, which is also saved with the user's record in the db.
# The token has configurable expiration.
# When the user clicks the url in the email, providing the token has not yet expired,
# he will be able to reset his password via a form.
#
# When using this submodule, supplying a mailer is mandatory.
#
# source://sorcery//lib/sorcery/model/submodules/reset_password.rb#12
module Sorcery::Model::Submodules::ResetPassword
  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#13
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/model/submodules/reset_password.rb#59
module Sorcery::Model::Submodules::ResetPassword::ClassMethods
  # Find user by token, also checks for expiration.
  # Returns the user if token found and is valid.
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#62
  def load_from_reset_password_token(token, &block); end

  protected

  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#80
  def define_reset_password_fields; end

  # This submodule requires the developer to define his own mailer class to be used by it
  # when reset_password_mailer_disabled is false
  #
  # @raise [ArgumentError]
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#75
  def validate_mailer_defined; end
end

# source://sorcery//lib/sorcery/model/submodules/reset_password.rb#87
module Sorcery::Model::Submodules::ResetPassword::InstanceMethods
  # Clears token and tries to update the new password for the user.
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#127
  def change_password(new_password, raise_on_failure: T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#133
  def change_password!(new_password); end

  # Generates a reset code with expiration and sends an email to the user.
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#99
  def deliver_reset_password_instructions!; end

  # Generates a reset code with expiration
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#89
  def generate_reset_password_token!; end

  # Increment access_count_to_reset_password_page attribute.
  # For example, access_count_to_reset_password_page attribute is over 1, which
  # means the user doesn't have a right to access.
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#115
  def increment_password_reset_page_access_counter; end

  # Reset access_count_to_reset_password_page attribute into 0.
  # This is expected to be used after sending an instruction email.
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#121
  def reset_password_reset_page_access_counter; end

  protected

  # Clears the token.
  #
  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#146
  def clear_reset_password_token; end

  # source://sorcery//lib/sorcery/model/submodules/reset_password.rb#141
  def send_reset_password_email!; end
end

# This submodule adds the ability to make the user activate his account via email
# or any other way in which he can recieve an activation code.
# with the activation code the user may activate his account.
# When using this submodule, supplying a mailer is mandatory.
#
# source://sorcery//lib/sorcery/model/submodules/user_activation.rb#8
module Sorcery::Model::Submodules::UserActivation
  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#9
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/model/submodules/user_activation.rb#59
module Sorcery::Model::Submodules::UserActivation::ClassMethods
  # Find user by token, also checks for expiration.
  # Returns the user if token found and is valid.
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#62
  def load_from_activation_token(token, &block); end

  protected

  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#80
  def define_user_activation_fields; end

  # This submodule requires the developer to define his own mailer class to be used by it
  # when activation_mailer_disabled is false
  #
  # @raise [ArgumentError]
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#75
  def validate_mailer_defined; end
end

# source://sorcery//lib/sorcery/model/submodules/user_activation.rb#89
module Sorcery::Model::Submodules::UserActivation::InstanceMethods
  # clears activation code, sets the user as 'active' and optionaly sends a success email.
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#99
  def activate!; end

  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#90
  def setup_activation; end

  # Returns the value of attribute skip_activation_needed_email.
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#107
  def skip_activation_needed_email; end

  # Sets the attribute skip_activation_needed_email
  #
  # @param value the value to set the attribute skip_activation_needed_email to.
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#107
  def skip_activation_needed_email=(_arg0); end

  # Returns the value of attribute skip_activation_success_email.
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#107
  def skip_activation_success_email; end

  # Sets the attribute skip_activation_success_email
  #
  # @param value the value to set the attribute skip_activation_success_email to.
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#107
  def skip_activation_success_email=(_arg0); end

  protected

  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#132
  def prevent_non_active_login; end

  # called automatically after user initial creation.
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#112
  def send_activation_needed_email!; end

  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#126
  def send_activation_needed_email?; end

  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#116
  def send_activation_success_email!; end

  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/model/submodules/user_activation.rb#120
  def send_activation_success_email?; end
end

# This module encapsulates the logic for temporary token.
# A temporary token is created to identify a user in scenarios
# such as reseting password and activating the user by email.
#
# source://sorcery//lib/sorcery/model/temporary_token.rb#8
module Sorcery::Model::TemporaryToken
  mixes_in_class_methods ::Sorcery::Model::TemporaryToken::ClassMethods

  class << self
    # Random code, used for salt and temporary tokens.
    #
    # source://sorcery//lib/sorcery/model/temporary_token.rb#16
    def generate_random_token; end

    # @private
    #
    # source://sorcery//lib/sorcery/model/temporary_token.rb#9
    def included(base); end
  end
end

# source://sorcery//lib/sorcery/model/temporary_token.rb#20
module Sorcery::Model::TemporaryToken::ClassMethods
  # source://sorcery//lib/sorcery/model/temporary_token.rb#21
  def load_from_token(token, token_attr_name, token_expiration_date_attr = T.unsafe(nil), &block); end

  protected

  # source://sorcery//lib/sorcery/model/temporary_token.rb#37
  def check_expiration_date(user, token_expiration_date_attr); end

  # @yield [options[:user], options[:failure]]
  #
  # source://sorcery//lib/sorcery/model/temporary_token.rb#45
  def token_response(options = T.unsafe(nil)); end
end

# source://sorcery//lib/sorcery.rb#39
module Sorcery::Protocols; end

# source://sorcery//lib/sorcery/protocols/oauth.rb#5
module Sorcery::Protocols::Oauth
  # source://sorcery//lib/sorcery/protocols/oauth.rb#16
  def authorize_url(args); end

  # source://sorcery//lib/sorcery/protocols/oauth.rb#23
  def get_access_token(args); end

  # source://sorcery//lib/sorcery/protocols/oauth.rb#10
  def get_request_token(token = T.unsafe(nil), secret = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/protocols/oauth.rb#6
  def oauth_version; end

  protected

  # source://sorcery//lib/sorcery/protocols/oauth.rb#32
  def get_consumer; end
end

# source://sorcery//lib/sorcery/protocols/oauth2.rb#5
module Sorcery::Protocols::Oauth2
  # source://sorcery//lib/sorcery/protocols/oauth2.rb#10
  def authorize_url(options = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/protocols/oauth2.rb#32
  def build_client(options = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/protocols/oauth2.rb#20
  def get_access_token(args, options = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/protocols/oauth2.rb#6
  def oauth_version; end
end

# source://sorcery//lib/sorcery.rb#54
module Sorcery::TestHelpers; end

# Internal TestHelpers are used to test the gem, internally, and should not be used to test apps *using* sorcery.
# This file will be included in the spec_helper file.
#
# source://sorcery//lib/sorcery/test_helpers/internal.rb#5
module Sorcery::TestHelpers::Internal
  # source://sorcery//lib/sorcery/test_helpers/internal.rb#26
  def build_new_user(attributes_hash = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/test_helpers/internal.rb#37
  def create_new_external_user(provider, attributes_hash = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/test_helpers/internal.rb#31
  def create_new_user(attributes_hash = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/test_helpers/internal.rb#45
  def custom_create_new_external_user(provider, authentication_class, attributes_hash = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/test_helpers/internal.rb#55
  def sorcery_model_property_set(property, *values); end

  # source://sorcery//lib/sorcery/test_helpers/internal.rb#61
  def update_model(&block); end

  private

  # reload user class between specs
  # so it will be possible to test the different submodules in isolation
  #
  # source://sorcery//lib/sorcery/test_helpers/internal.rb#69
  def reload_user_class; end

  class << self
    # @private
    #
    # source://sorcery//lib/sorcery/test_helpers/internal.rb#6
    def included(_base); end
  end
end

# source://sorcery//lib/sorcery/test_helpers/internal/rails.rb#4
module Sorcery::TestHelpers::Internal::Rails
  include ::Sorcery::TestHelpers::Rails::Controller

  # This helper is used to fake multiple users signing in in tests.
  # It does so by clearing @current_user, thus allowing a new user to login,
  # all this without calling the :logout action explicitly.
  # A dirty dirty hack.
  #
  # source://sorcery//lib/sorcery/test_helpers/internal/rails.rb#62
  def clear_user_without_logout; end

  # source://sorcery//lib/sorcery/test_helpers/internal/rails.rb#54
  def sorcery_controller_external_property_set(provider, property, value); end

  # source://sorcery//lib/sorcery/test_helpers/internal/rails.rb#50
  def sorcery_controller_property_set(property, value); end

  # source://sorcery//lib/sorcery/test_helpers/internal/rails.rb#13
  def sorcery_reload!(submodules = T.unsafe(nil), options = T.unsafe(nil)); end
end

# source://sorcery//lib/sorcery/test_helpers/internal/rails.rb#7
Sorcery::TestHelpers::Internal::Rails::SUBMODULES_AUTO_ADDED_CONTROLLER_FILTERS = T.let(T.unsafe(nil), Array)

# source://sorcery//lib/sorcery.rb#57
module Sorcery::TestHelpers::Rails; end

# source://sorcery//lib/sorcery/test_helpers/rails/controller.rb#4
module Sorcery::TestHelpers::Rails::Controller
  # @return [Boolean]
  #
  # source://sorcery//lib/sorcery/test_helpers/rails/controller.rb#15
  def logged_in?; end

  # source://sorcery//lib/sorcery/test_helpers/rails/controller.rb#5
  def login_user(user = T.unsafe(nil), _test_context = T.unsafe(nil)); end

  # source://sorcery//lib/sorcery/test_helpers/rails/controller.rb#11
  def logout_user; end
end

# source://sorcery//lib/sorcery/test_helpers/rails/integration.rb#4
module Sorcery::TestHelpers::Rails::Integration
  # Accepts arguments for user to login, route to use and HTTP method
  # Defaults - @user, 'sessions_url' and POST
  #
  # source://sorcery//lib/sorcery/test_helpers/rails/integration.rb#7
  def login_user(user = T.unsafe(nil), route = T.unsafe(nil), http_method = T.unsafe(nil)); end

  # Accepts route and HTTP method arguments
  # Default - 'logout_url' and GET
  #
  # source://sorcery//lib/sorcery/test_helpers/rails/integration.rb#18
  def logout_user(route = T.unsafe(nil), http_method = T.unsafe(nil)); end
end

# source://sorcery//lib/sorcery/test_helpers/rails/request.rb#4
module Sorcery::TestHelpers::Rails::Request
  # Accepts arguments for user to login, the password, route to use and HTTP method
  # Defaults - @user, 'secret', 'user_sessions_url' and http_method: POST
  #
  # source://sorcery//lib/sorcery/test_helpers/rails/request.rb#7
  def login_user(user = T.unsafe(nil), password = T.unsafe(nil), route = T.unsafe(nil), http_method = T.unsafe(nil)); end
end

# source://sorcery//lib/sorcery/version.rb#2
Sorcery::VERSION = T.let(T.unsafe(nil), String)
